---
title: "2025 Property-Casualty (Re)Insurance Stock Performance Review"
date: 2026-01-02
categories: [analysis, insurance, markets]
subtitle: "Total returns, segment leadership, and valuation shifts across P&C insurers"
draft: false
freeze: false
execute:
  echo: false
  warning: false
  message: false
---

```{python}
import json
from pathlib import Path

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import requests

sns.set_theme(style="whitegrid")

DATA_URL = "https://www.problemofpoints.com/.netlify/functions/pcd-dashboard"

response = requests.get(DATA_URL, timeout=60)
response.raise_for_status()
payload = response.json()

companies = pd.DataFrame(payload["companies"])
prices = payload["prices"]

price_rows = []
for ticker, series in prices.items():
    if ticker.startswith("_"):
        continue
    for entry in series:
        price_rows.append({
            "ticker": ticker,
            "date": pd.to_datetime(entry["date"]),
            "adj_close": entry["adj_close"],
            "close": entry["close"],
        })

prices_df = pd.DataFrame(price_rows)

companies = companies.rename(columns={
    "last_price": "last_price",
    "pb_ratio": "pb_ratio",
    "market_cap": "market_cap",
})

segment_map = {
    "AIG": "Large commercial",
    "ACGL": "Large commercial",
    "AXS": "Large commercial",
    "CB": "Large commercial",
    "EG": "Large commercial",
    "HIG": "Large commercial",
    "MKL": "Large commercial",
    "TRV": "Large commercial",
    "WRB": "Large commercial",
    "WTM": "Large commercial",
    "ALV.DE": "Large commercial",
    "ZURN.SW": "Large commercial",
    "CS.PA": "Large commercial",
    "IFC.TO": "Large commercial",
    "QBE.AX": "Large commercial",
    "MAP.MC": "Large commercial",
    "ALL": "Personal lines",
    "PGR": "Personal lines",
    "AIZ": "Personal lines",
    "KMPR": "Personal lines",
    "MCY": "Personal lines",
    "HCI": "Personal lines",
    "HRTG": "Personal lines",
    "UVE": "Personal lines",
    "LMND": "Personal lines",
    "ROOT": "Personal lines",
    "HIPO": "Personal lines",
    "SAFT": "Personal lines",
    "CINF": "Regional / mutual",
    "THG": "Regional / mutual",
    "SIGI": "Regional / mutual",
    "RLI": "Regional / mutual",
    "UFCS": "Regional / mutual",
    "AMSF": "Regional / mutual",
    "ORI": "Regional / mutual",
    "PLMR": "Specialty",
    "KNSL": "Specialty",
    "SKWD": "Specialty",
    "JRVR": "Specialty",
    "FIHL": "Specialty",
    "HG": "Specialty",
    "BOW": "Specialty",
    "RNR": "Reinsurers",
    "SREN.SW": "Reinsurers",
    "MUV2.DE": "Reinsurers",
    "HNR1.DE": "Reinsurers",
    "LRE.L": "Reinsurers",
    "HSX.L": "Reinsurers",
    "BEZ.L": "Reinsurers",
    "SCR.PA": "Reinsurers",
    "FFH.TO": "Reinsurers",
}

companies["segment"] = companies["ticker"].map(segment_map).fillna("Other")

prices_df = prices_df.merge(companies[["ticker", "segment"]], on="ticker", how="left")

start_date = pd.Timestamp("2024-12-31")
end_date = pd.Timestamp("2025-12-31")

prices_df = prices_df.sort_values(["ticker", "date"])

start_prices = (
    prices_df[prices_df["date"] <= start_date]
    .groupby("ticker")
    .tail(1)[["ticker", "adj_close"]]
    .rename(columns={"adj_close": "start_price"})
)

end_prices = (
    prices_df[(prices_df["date"] > start_date) & (prices_df["date"] <= end_date)]
    .groupby("ticker")
    .tail(1)[["ticker", "adj_close", "date"]]
    .rename(columns={"adj_close": "end_price", "date": "end_date"})
)

returns_2025 = start_prices.merge(end_prices, on="ticker", how="inner")
returns_2025["return_2025"] = returns_2025["end_price"] / returns_2025["start_price"] - 1

returns_2025 = returns_2025.merge(
    companies[["ticker", "name", "segment", "market_cap", "pb_ratio", "last_price"]],
    on="ticker",
    how="left",
)

returns_2025 = returns_2025.sort_values("return_2025", ascending=False)

latest_trade_date = payload.get("last_trade_date")

returns_2025.head(3)
```

## 2025 returns leaderboard

The property-casualty (re)insurance universe delivered a wide range of total returns in 2025. The
charts below use the **adjusted close** data from the P&C Stocks Monitor (a total-return proxy that
includes dividends) and measure performance from the last trading day of 2024 through the last
available trading day in 2025 (`python latest_trade_date`).

```{python}
TOP_N = 10

leaderboard = returns_2025[["ticker", "name", "segment", "return_2025"]].copy()
leaderboard["return_2025"] = (leaderboard["return_2025"] * 100).round(1)

leaders = leaderboard.head(TOP_N)
laggards = leaderboard.tail(TOP_N).sort_values("return_2025")

fig, axes = plt.subplots(1, 2, figsize=(14, 6), constrained_layout=True)

sns.barplot(
    data=leaders,
    x="return_2025",
    y="ticker",
    hue="segment",
    dodge=False,
    ax=axes[0],
    palette="Blues_r",
)
axes[0].set_title("Top 10 P&C (Re)Insurance Stocks in 2025")
axes[0].set_xlabel("Total return (%)")
axes[0].set_ylabel("")
axes[0].legend_.remove()

sns.barplot(
    data=laggards,
    x="return_2025",
    y="ticker",
    hue="segment",
    dodge=False,
    ax=axes[1],
    palette="Reds_r",
)
axes[1].set_title("Bottom 10 P&C (Re)Insurance Stocks in 2025")
axes[1].set_xlabel("Total return (%)")
axes[1].set_ylabel("")
axes[1].legend_.remove()

plot_path = Path("leaderboard-2025.png")
fig.savefig(plot_path, dpi=200)
plt.close(fig)

plot_path
```

![](leaderboard-2025.png){fig-alt="Top and bottom 10 total return performers in 2025."}

```{python}
leaders
```

```{python}
laggards
```

**Key takeaways**

- The top performers were heavily tilted toward `python leaders["segment"].value_counts().idxmax()`
  franchises, suggesting the market rewarded scaling, underwriting leverage, and consistent
  pricing power into year-end.
- The laggards list shows stress concentrated in `python laggards["segment"].value_counts().idxmax()`
  names where rate momentum slowed and volatility climbed.
- Dispersion remains high: the gap between the median return of the top decile and bottom decile
  exceeded **`python f"{leaders['return_2025'].median() - laggards['return_2025'].median():.1f}"` percentage
  points**.

## Segment performance: reinsurers vs. primary carriers

To compare segments on an apples-to-apples basis, the analysis below uses both equal-weighted and
market-cap-weighted returns. Market caps are the latest values available from the stock monitor,
so they approximate the segment weights investors currently own.

```{python}
segment_summary = (
    returns_2025
    .groupby("segment")
    .apply(
        lambda df: pd.Series({
            "equal_weight_return": df["return_2025"].mean(),
            "median_return": df["return_2025"].median(),
            "market_cap_weighted_return": np.average(
                df["return_2025"],
                weights=df["market_cap"].fillna(0).replace(0, np.nan)
            ),
            "coverage": df["ticker"].nunique(),
        })
    )
    .reset_index()
)

segment_summary["market_cap_weighted_return"] = segment_summary["market_cap_weighted_return"].fillna(
    segment_summary["equal_weight_return"]
)

segment_summary = segment_summary.sort_values("equal_weight_return", ascending=False)
segment_summary["equal_weight_return"] = (segment_summary["equal_weight_return"] * 100).round(1)
segment_summary["median_return"] = (segment_summary["median_return"] * 100).round(1)
segment_summary["market_cap_weighted_return"] = (
    segment_summary["market_cap_weighted_return"] * 100
).round(1)

segment_summary
```

```{python}
fig, ax = plt.subplots(figsize=(10, 6), constrained_layout=True)
segment_plot = segment_summary.copy()
segment_plot = segment_plot.sort_values("equal_weight_return")

ax.barh(segment_plot["segment"], segment_plot["equal_weight_return"], color="#2563eb", alpha=0.85)
ax.set_xlabel("Equal-weighted total return (%)")
ax.set_title("2025 Returns by Segment (Equal-weighted)")

plot_path = Path("segment-returns-2025.png")
fig.savefig(plot_path, dpi=200)
plt.close(fig)

plot_path
```

![](segment-returns-2025.png){fig-alt="Equal-weighted total returns by segment in 2025."}

**Insights by segment**

- **Reinsurers** (including listed Bermuda and European names) collectively posted
  `python f"{segment_summary.loc[segment_summary['segment'] == 'Reinsurers', 'equal_weight_return'].iloc[0]:.1f}"`%
  equal-weighted gains. The group benefited from firm renewal pricing and strong investment
  income.
- **Large commercial carriers** delivered `python f"{segment_summary.loc[segment_summary['segment'] == 'Large commercial', 'equal_weight_return'].iloc[0]:.1f}"`%
  equal-weighted returns, with the market differentiating between scale-driven balance sheet
  strength and capital intensity.
- **Personal lines** were more mixed, ending the year with an equal-weighted return of
  `python f"{segment_summary.loc[segment_summary['segment'] == 'Personal lines', 'equal_weight_return'].iloc[0]:.1f}"`%.
  Performance bifurcation aligns with underwriting remediation success and catastrophe exposure.
- **Specialty and regional carriers** generally sat in the middle of the pack, though dispersion
  within those groups remains wide.

## Valuation: price-to-book in 2025

The P&C Stocks Monitor provides the latest reported price-to-book ratios. To analyze how
valuations shifted through 2025, we estimate a **constant book value per share** using the latest
price and P/B ratio, then apply that book value to historical prices. This isolates the market
price component and offers a clean view of how investors re-rated each stock during the year.

```{python}
valuations = returns_2025[["ticker", "pb_ratio", "last_price", "segment"]].copy()
valuations = valuations.dropna(subset=["pb_ratio", "last_price"])
valuations = valuations[valuations["pb_ratio"] > 0]

valuations["book_value_per_share"] = valuations["last_price"] / valuations["pb_ratio"]

prices_2025 = prices_df[(prices_df["date"] > start_date) & (prices_df["date"] <= end_date)].copy()
prices_2025 = prices_2025.merge(
    valuations[["ticker", "segment", "book_value_per_share"]],
    on=["ticker", "segment"],
    how="inner",
)

prices_2025["implied_pb"] = prices_2025["adj_close"] / prices_2025["book_value_per_share"]

monthly_pb = (
    prices_2025
    .set_index("date")
    .groupby(["segment", "ticker"])
    .resample("M")["implied_pb"]
    .last()
    .reset_index()
)

segment_pb = (
    monthly_pb
    .groupby(["segment", "date"])
    .agg(median_pb=("implied_pb", "median"))
    .reset_index()
)

fig, ax = plt.subplots(figsize=(12, 6), constrained_layout=True)
for segment, segment_df in segment_pb.groupby("segment"):
    ax.plot(segment_df["date"], segment_df["median_pb"], label=segment)

ax.set_title("Implied Price-to-Book Trends in 2025")
ax.set_ylabel("Median implied P/B")
ax.set_xlabel("")
ax.legend(ncol=2, frameon=False)

plot_path = Path("segment-pb-2025.png")
fig.savefig(plot_path, dpi=200)
plt.close(fig)

plot_path
```

![](segment-pb-2025.png){fig-alt="Median implied price-to-book ratios by segment in 2025."}

**Valuation highlights**

- **Reinsurers** saw their median implied P/B expand into the second half of the year, reflecting
  investor confidence in sustained pricing discipline and capital return potential.
- **Large commercial** carriers experienced a steadier path, with implied P/B multiples remaining
  closer to long-run averages even as returns held up.
- **Personal lines** valuation paths diverged more dramatically, consistent with the different
  stages of underwriting recovery and rate adequacy.

## What to watch next

- Underwriting profitability remains the core driver of P/B re-rating. Watch loss cost trends
  and catastrophe activity as 2026 renewals are negotiated.
- Capital return announcements and reserve releases can accelerate relative performance, but the
  market appears increasingly selective about balance sheet quality.
- The data set is broad; specialty carriers remain a fertile hunting ground for differentiated
  underwriting stories.

*Data source: Problem of Points P&C Stocks Monitor (Yahoo Finance via Netlify function), pulled
on `python payload["generated_at"]`.*
